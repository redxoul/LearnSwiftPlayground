import Foundation

/*
 // Binary Search
 // 이진 탐색
 
 '오름차순으로 정렬된 리스트'에서 특정한 값의 위치를 찾는 알고리즘입니다.
 중간의 값을 임의의 값으로 선택해, 양옆의 크고 작음을 판별합니다.
 정렬된 리스트에서만 가능한 것이 단점입니다
 검색이 반복될 때마다 반으로 줄어들기 때문에 속도가 빠릅니다.
 
 아래 배열에서 34를 찾는 예시
 
 배열 가장 중간의 값을 X의 값과 비교하고
 X가 더 크다면, 중간을 기준으로 오른쪽 배열들만을 이용해 다시 탐색,
 X가 더 작다면, 중간을 기준으로 왼쪽의 배열들만을 이용해 다시 탐색합니다.

 X의 값을 찾아낼 때까지 위의 과정을 반복합니다.
 범위를 절반씩 줄여주기 때문에 '시간 복잡도 O(logN)'
 선형탐색이 *O*(*N*) 인데 반해 매우 빠른 속도입니다.
 
   0   1  2   3   4   5   6    7    8   9   10  11  12  13  14  15
 [(2)  6  11  13  18  20  22  (27)  29  30  34  38  41  42  45  (47)]
 low                          midle                             high
 
 
  0  1  2   3   4   5   6    7    8    9   10   11   12  13  14   15
 [2  6  11  13  18  20  22   27  (29)  30  34  (38)  41  42  45  (47)]
                                 low           midle             high
 
 
  0  1  2   3   4   5   6   7     8    9     10   11  12  13  14  15
 [2  6  11  13  18  20  22  27  (29)  (30)  (34)  38  41  42  45  47]
                                 low  midle  high
 
 
  0  1  2   3   4   5   6   7   8    9    10   11   12  13  14  15
 [2  6  11  13  18  20  22  27  29   30  (34)  38   41  42  45  47]
                                         l,m,h
 
 
 */

public func binarySearch(_ A: [Int], _ taget: Int) -> Int {
    // A: 정렬된 배열
    // target: 찾을 정수
    // A 안에서 target의 index를 찾음(없으면 -1)
    
    var left = 0
    var right = A.count-1
    
    while left <= right {
        let mid = Int((left+right)/2)
        
        if A[mid] == taget {
            return mid
        }
        else if (A[mid] < taget) {
            left = mid + 1
        }
        else {
            right = mid - 1
        }
    }
    
    return -1
}
